#+TITLE: ABQ Multi-Host Messaging
#+DATE: 2026-01-28

* The Problem

ABQ is filesystem-based. Cross-machine messaging requires bridging the gap.

#+begin_example
host-a (sender)                 host-b (receiver)
┌─────────────────┐            ┌─────────────────┐
│ ~/.abq/         │     ?      │ ~/.abq/         │
│   channels/     │ ────────── │   channels/     │
│     reports/    │            │     reports/    │
└─────────────────┘            └─────────────────┘
#+end_example

* Solutions

** Option 1: SSH + Remote Execution (Simplest)

From host-a, execute abq on host-b:

#+begin_src bash
# host-a → host-b: send message by running abq remotely
ssh $REMOTE_HOST 'cd /path/to/abq && \
  uv run abq send reports signal \
  "{\"signal\": \"test_complete\", \"host\": \"host-a\"}"'
#+end_src

Pros: Simple, no file transfer
Cons: Requires SSH access, latency

** Option 2: SCP Message Files (What We Did)

Write message locally, copy to remote:

#+begin_src bash
# On host-a: send locally first
uv run abq send reports signal '{"signal": "test"}'

# Copy the message file to host-b
scp ~/.abq/channels/reports/requests/req_*.json \
    $REMOTE_HOST:~/.abq/channels/reports/requests/
#+end_src

Pros: Works with any transport (rsync, scp, usb stick)
Cons: Two-step process, need to manage file cleanup

** Option 3: Shared Filesystem (NFS/SSHFS)

Mount remote ABQ directory:

#+begin_src bash
# On host-a: mount host-b's ~/.abq
sshfs $REMOTE_HOST:~/.abq ~/.abq-remote

# Send directly to host-b's queue
ABQ_HOME=~/.abq-remote abq send reports signal '{"from": "host-a"}'
#+end_src

Pros: Transparent, feels local
Cons: Network dependency, mount management

** Option 4: Rsync Sync (Batch)

Periodically sync queues:

#+begin_src bash
# Cron job: sync outbox to remote inbox
*/1 * * * * rsync -a ~/.abq/outbox/ $REMOTE_HOST:~/.abq/channels/reports/requests/
#+end_src

Pros: Handles offline, batches efficiently
Cons: Not real-time, complexity

** Option 5: ABQ Bridge Daemon (Future)

A small daemon that watches local outbox and forwards via SSH:

#+begin_src python
# Hypothetical future feature
abq bridge $REMOTE_HOST --channel reports
#+end_src

* Tested Scenario: Cross-Host Messaging

** Setup

| Host | OS | ABQ Role |
|--------+----+----------|
| host-b | FreeBSD 14.x | Receiver (agent listening) |
| host-a | FreeBSD 15.x | Sender (test results) |

** What Happened

1. Agent on host-a tried to send message to host-b
2. Message went to host-a's LOCAL ~/.abq (oops!)
3. Agent realized the mistake
4. Used SCP to copy message file to host-b
5. Agent on host-b successfully received it

** Actual Commands Run

#+begin_src bash
# On host-a: accidentally sent locally
uv run abq send reports signal '{"signal": "test_complete", ...}'
# Output: Sent: req_<id> -> reports
# But this went to host-a's filesystem!

# Discovery: check host-b's queue
ssh $REMOTE_HOST 'ls ~/.abq/channels/reports/requests/*.json'
# Found a different message (from earlier)

# Fix: copy the message to host-b
scp ~/.abq/channels/reports/requests/req_<id>.json \
    $REMOTE_HOST:~/.abq/channels/reports/requests/

# On host-b: receive it
uv run abq recv reports
# ID: req_<id>
# Type: signal
# From: github.com/<org>/<repo>/main
# Content: {"signal": "test_complete", ...}
#+end_src

** Lesson Learned

ABQ is explicitly LOCAL-FIRST. Multi-host requires explicit transport.

This is a FEATURE, not a bug:
- No hidden network dependencies
- Works offline
- Debuggable (it's just files)
- You choose the transport that fits your security model

* Recommended Pattern for Multi-Host

#+begin_src bash
#!/bin/bash
# ~/bin/abq-remote - send to remote ABQ instance
# Usage: abq-remote <host> <channel> <type> <content>

REMOTE_HOST="$1"
CHANNEL="$2"
MSG_TYPE="$3"
CONTENT="$4"

ssh "$REMOTE_HOST" "cd /path/to/abq && \
  uv run abq send '$CHANNEL' '$MSG_TYPE' '$CONTENT'"
#+end_src

Then:

#+begin_src bash
abq-remote $REMOTE_HOST reports signal '{"test": "passed", "host": "$(hostname)"}'
#+end_src

* When to Use NATS Instead

If you need:
- Real-time cross-machine messaging
- Multiple subscribers
- Message persistence across network
- Pub/sub patterns at scale

Then ABQ isn't the right tool. Use [[https://nats.io/][NATS]] (single binary, easy to run).

ABQ is for: same-machine agent coordination where debuggability > latency.
