#+TITLE: Agent Bus (aq)
#+AUTHOR: JW
#+DATE: 2025-01-28
#+STARTUP: overview

A minimal file-based message bus for coordinating AI agents across repositories, worktrees, and processes. Inspired by [[https://github.com/steveyegge/efrit][Efrit's queue system]] but generalized for any agent-to-agent communication.

* Problem Statement

When running AI agents (Claude Code, Cursor, Efrit) in separate contexts - different repos, worktrees, or processes - they need a simple way to coordinate:

- *Test agent in repo A* needs to signal *app agent in repo B* when tests pass
- *Main branch agent* needs to dispatch work to *feature branch agents*
- *Supervisor agent* needs to monitor/coordinate *worker agents*

The solution should be:
- Zero daemon / zero broker (no NATS, Redis, RabbitMQ to run)
- Work with any language (shell, Python, Ruby, Node, etc.)
- Git-aware (agents identified by org/repo/branch)
- Trivially debuggable (just JSON files in directories)

* Architecture

#+begin_example
~/.aq/
├── registry.json          # Agent/channel metadata
├── channels/
│   ├── test-runner/       # Channel: test-runner
│   │   ├── requests/      # Incoming messages
│   │   ├── processing/    # In-flight (prevents double-pickup)
│   │   ├── responses/     # Replies
│   │   └── archive/       # Completed
│   ├── app-agent/
│   └── broadcast/         # Global pubsub
├── agents/                # Per-agent state (optional)
└── logs/
#+end_example

* Protocol

** Request

#+begin_src json
{
  "id": "req_018d5a3b2c4e",
  "version": "1.0.0",
  "type": "signal",
  "from": {
    "agent": "github.com/myorg/tests/main",
    "pid": 12345,
    "pwd": "/path/to/repo"
  },
  "to": "app-agent",
  "content": "{\"signal\": \"tests_passed\", \"count\": 42}",
  "timestamp": "2025-01-28T12:00:00Z",
  "ttl": 300
}
#+end_src

** Response

#+begin_src json
{
  "id": "req_018d5a3b2c4e",
  "version": "1.0.0",
  "status": "success",
  "from": {
    "agent": "github.com/myorg/app/main",
    "pid": 12346
  },
  "result": "acknowledged",
  "timestamp": "2025-01-28T12:00:01Z"
}
#+end_src

** Message Types

| Type      | Purpose                              | Content                      |
|-----------+--------------------------------------+------------------------------|
| =signal=  | Notifications (tests passed, build done) | ={signal: string, data?: any}= |
| =command= | Natural language instructions        | String                       |
| =eval=    | Execute code/shell                   | String                       |
| =status=  | Health check / heartbeat             | ={}=                         |

* Quick Start

#+begin_src bash
# Initialize
aq-init

# Create channels
aq-channel create test-runner
aq-channel create app-agent

# Terminal 1: Watch for signals
aq watch app-agent --handler ./my-handler.sh

# Terminal 2: Send a signal
aq send app-agent signal '{"signal": "tests_passed"}'
#+end_src

* Implementation

See [[file:agent-bus-spec.org][agent-bus-spec.org]] for the full tangleable implementation in Org mode.

* Research: Communication Patterns for Agent Coordination

** Related Systems

*** 1. Efrit (Emacs Agent)

[[https://github.com/steveyegge/efrit][Efrit]] pioneered the file-based queue approach for AI agent communication:

#+begin_example
.efrit/queues/
├── requests/
├── responses/
├── processing/
└── archive/
#+end_example

Efrit uses JSON messages with types: =eval=, =command=, =chat=, =status=. Other agents (Claude Code, Cursor) can interact via the [[https://modelcontextprotocol.io/][Model Context Protocol]] or directly via the filesystem queue.

*** 2. Unix Spool Pattern

The [[https://en.wikipedia.org/wiki/Spooling][spool directory pattern]] is a venerable Unix approach:
- Print spoolers (=/var/spool/lpd=)
- Mail queues (=/var/spool/mail=)
- Cron (=/var/spool/cron=)
- Batch systems (HTCondor, PBS)

Key characteristics:
- FIFO processing
- State directories: =new/= → =cur/= → =done/=
- Lock files prevent double-pickup
- No daemon required for submitters

*** 3. Maildir Format

The [[https://en.wikipedia.org/wiki/Maildir][Maildir]] format (used by qmail, Dovecot) solves similar problems:
- Atomic file creation (write to =tmp/=, rename to =new/=)
- No locking required
- Multiple readers safe

** Theoretical Foundations

*** Actor Model

The [[https://en.wikipedia.org/wiki/Actor_model][Actor Model]] (Hewitt, 1973) defines agents with:
- *Mailbox*: Queue of incoming messages
- *Behavior*: How to process each message
- *State*: Private, mutable only by the actor
- *Address*: How other actors find this one

From [[https://www.erlang.org/doc/design_principles/des_princ.html][Erlang OTP]]:
- Lightweight processes (~300 bytes each)
- Asynchronous message passing (no shared memory)
- Supervision trees for fault tolerance
- "Let it crash" philosophy

The =aq= design maps directly:
- Mailbox = =requests/= directory
- Address = =github.com/org/repo/branch=
- Supervision = external (systemd, supervisor script)

*** IPC Patterns

From [[https://en.wikipedia.org/wiki/Inter-process_communication][IPC literature]]:

| Pattern        | Transport        | Use Case            |
|----------------+------------------+---------------------|
| Pipes          | stdin/stdout     | Linear pipelines    |
| Message Queues | Kernel/filesystem | Async decoupled    |
| Shared Memory  | mmap             | High bandwidth      |
| Sockets        | TCP/Unix         | Network/local       |
| Signals        | Kernel           | Simple notifications |

Filesystem-based queues trade throughput for simplicity and debuggability.

*** Contract Net Protocol

[[http://www.fipa.org/specs/fipa00029/SC00029H.html][FIPA Contract Net]] (1980) formalized multi-agent task allocation:

1. *Manager* broadcasts call-for-proposals (CFP)
2. *Contractors* submit bids (propose)
3. *Manager* selects winner(s) (accept/reject)
4. *Contractor* performs task, reports result

The =aq= protocol supports this:

#+begin_src bash
# Manager: CFP
aq send broadcast signal '{"signal":"cfp","task":"analyze_logs"}'

# Contractors respond to reply_to channel
aq send manager signal '{"signal":"propose","bid":{"time":5}}'

# Manager accepts
aq send contractor-1 command "analyze /var/log/app.log"
#+end_src

*** Publish-Subscribe

[[https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern][Pub/Sub]] decouples producers from consumers:

- *Topic-based*: Subscribe to named channels
- *Content-based*: Subscribe to message patterns

The =aq broadcast= channel provides topic-based pub/sub. Content filtering happens in handlers.

** Why Filesystem Queues?

For local agent coordination (two agents, same machine, "tests done, your turn"), here's how options compare:

| Option                 | Verdict                                                                                           |
|------------------------+---------------------------------------------------------------------------------------------------|
| *Named FIFO*           | Tempting, zero deps, but unidirectional and no persistence. If receiver isn't listening, gone.   |
| *Shared file + flock*  | Race conditions, no structure, have to invent locking. Pain.                                     |
| *SQLite*               | Actually underrated. Single file, ACID, survives crashes. But feels heavy for "hey, tests passed". |
| *Unix sockets*         | Fast (~0.1ms), but ephemeral. Requires both processes running.                                   |
| *D-Bus*                | Designed for this on Linux. Heavyweight, weird API, overkill for agents.                         |
| *Redis*                | Good pub/sub, but now you're running a daemon. For two processes?                                |
| *NATS*                 | Best "real" option if you need <10ms latency or complex routing. Still a daemon.                 |
| *ZeroMQ/nanomsg*       | No broker, fast. But now you're linking a library everywhere.                                    |
| *MQTT (mosquitto)*     | IoT-focused, lightweight. Still a daemon.                                                        |
| *Kafka*                | lol no                                                                                           |
| *IRC (ngircd/miniircd)* | Unironically fun but massive overkill                                                           |
| *Keybase*              | If you need encryption + multi-device, sure. You don't.                                          |
| *Efrit/fs-queue*       | Debuggable with =cat= and =jq=. Survives restarts. Works from any language. No daemon.           |

*The filesystem approach wins because the failure mode is "I can literally =ls= the queue and see what's stuck."* That's worth a lot when debugging agent coordination at 2am.

*** When to Use Something Else

| Scenario                                        | Recommendation           |
|-------------------------------------------------+--------------------------|
| Same machine, <10 agents, "tests passed" signals | *Filesystem queue*       |
| Same machine, need <10ms latency                | Unix sockets or ZeroMQ   |
| Multiple machines                               | NATS (single binary)     |
| Complex routing/filtering                       | NATS or Redis pub/sub    |
| Already running Redis                           | Just use Redis           |
| Need persistence + queries                      | SQLite                   |
| Enterprise/"we need Kafka"                      | NATS JetStream           |

** Alternative Transports

For higher throughput or more features:

| System         | Overhead | Features              | Use When               |
|----------------+----------+-----------------------+------------------------|
| *Filesystem*   | ~1ms     | Debuggable, zero-deps | Local, low-volume      |
| *Unix sockets* | ~0.1ms   | Fast, stream-based    | Same machine, high-vol |
| [[https://nats.io/][NATS]]          | ~0.5ms   | Pub/sub, req/reply    | Multi-machine          |
| [[https://zeromq.org/][ZeroMQ]]        | ~0.1ms   | No broker, patterns   | Library integration    |
| [[https://redis.io/][Redis]]         | ~0.5ms   | Pub/sub, persistence  | Already running Redis  |

The =aq= design prioritizes simplicity over performance. For most AI agent coordination (messages/second, not messages/millisecond), filesystem is sufficient.

** File Watching

Three approaches for detecting new messages:

*** 1. Polling (Portable)

#+begin_src python
while True:
    files = list(requests_dir.glob("*.json"))
    if files:
        process(files[0])
    time.sleep(0.1)
#+end_src

*** 2. inotify (Linux)

#+begin_src python
import inotify.adapters
i = inotify.adapters.Inotify()
i.add_watch(str(requests_dir))
for event in i.event_gen(yield_nones=False):
    if 'IN_CREATE' in event[1]:
        process(event[3])
#+end_src

*** 3. FSEvents/kqueue (macOS/BSD)

#+begin_src python
# Via fswatch or watchdog library
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
#+end_src

[[https://github.com/emcrisostomo/fswatch][fswatch]] provides cross-platform file watching:

#+begin_src bash
fswatch -0 ~/.aq/channels/my-agent/requests | xargs -0 -n1 ./handler.sh
#+end_src

The =aq watch= command uses polling (0.5s default) for portability. For lower latency, use inotify/FSEvents directly.

** Security Considerations

Filesystem-based queues inherit Unix permissions:
- Channel directories can be mode =700= (private) or =770= (group)
- Messages are readable by channel owner
- No authentication beyond filesystem permissions

For multi-user scenarios, consider:
- Separate channels per user/group
- Signed messages (JSON Web Signatures)
- Encrypted content (age, GPG)

** References

*** Papers

- [[https://pmc.ncbi.nlm.nih.gov/articles/PMC3435995/][A Communication Model to Integrate Request-Response and Publish-Subscribe]] (PMC, 2012)
- [[https://arxiv.org/html/2505.02279v1][Survey of Agent Interoperability Protocols: MCP, ACP, A2A, ANP]] (ArXiv, 2025)
- [[https://iceberg.mit.edu/protocol.pdf][Ripple Effect Protocol: Coordinating Agent Populations]] (MIT, 2024)

*** Specifications

- [[http://www.fipa.org/specs/fipa00029/SC00029H.html][FIPA Contract Net Interaction Protocol]]
- [[https://modelcontextprotocol.io/][Model Context Protocol]]
- [[https://agent-network-protocol.com/specs/white-paper.html][Agent Network Protocol]]

*** Implementations

- [[https://github.com/steveyegge/efrit][Efrit]] - Emacs AI agent with file-based queue
- [[https://github.com/emcrisostomo/fswatch][fswatch]] - Cross-platform file change monitor
- [[https://cr.yp.to/proto/maildir.html][Maildir]] - djb's maildir specification

*** Patterns

- [[https://en.wikipedia.org/wiki/Unix_philosophy][Unix Philosophy]]
- [[https://en.wikipedia.org/wiki/Actor_model][Actor Model]]
- [[https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber][Publisher-Subscriber Pattern]]
- [[https://www.erlang.org/doc/design_principles/des_princ.html][Erlang OTP Design Principles]]

* License

MIT
